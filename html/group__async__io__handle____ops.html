<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Handle Ops</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classboost_1_1afio_1_1path.html">boost::afio::path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__io__handle____ops.html#ga94a8c3e4b9c01733ba077ee0cd17b0de">boost::afio::handle::path</a> (bool refresh=false)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the path of this i/o handle right now if the handle is open and <em>refresh</em> is true, else last known good. May be null if the file has been deleted.  <a href="#ga94a8c3e4b9c01733ba077ee0cd17b0de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual directory_entry&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__io__handle____ops.html#ga491efe072ab2b3ca2d9cf044f8eed1ab">boost::afio::handle::direntry</a> (metadata_flags wanted=directory_entry::metadata_fastpath())=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mostly filled <a class="el" href="classboost_1_1afio_1_1directory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> for the file or directory referenced by this handle. Use `metadata_flags::All` if you want it as complete as your platform allows, even at the cost of severe performance loss.  <a href="#ga491efe072ab2b3ca2d9cf044f8eed1ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classboost_1_1afio_1_1path.html">boost::afio::path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__io__handle____ops.html#ga06c44b7c2c3fef3a223bf9e3843d701f">boost::afio::handle::target</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target path of this handle if it is a symbolic link.  <a href="#ga06c44b7c2c3fef3a223bf9e3843d701f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__io__handle____ops.html#gaa637967d05be4d03eadb419dac95bf3c">boost::afio::handle::link</a> (const path_req &amp;req)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hard links the file to a new location on the same volume.  <a href="#gaa637967d05be4d03eadb419dac95bf3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__io__handle____ops.html#gae7dbd14a44e4d306804ef2766057e5ae">boost::afio::handle::unlink</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the file from its present location as determined by path(true), which could be any hard link on those operating systems with an unstable path(true). Other links may remain to the same file.  <a href="#gae7dbd14a44e4d306804ef2766057e5ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__io__handle____ops.html#ga7745df4fa1a42a9ae080de6ad8f72419">boost::afio::handle::atomic_relink</a> (const path_req &amp;req)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Links the file to a new location and unlinks the file from its present location as determined by path(true), <em>atomically overwriting any file entry at the new location</em>. Very useful for preparing file content elsewhere and once ready, atomically making it visible at some named location to other processes. Note that operating systems with an unstable path(true) may relink any hard link to the file to the new location.  <a href="#ga7745df4fa1a42a9ae080de6ad8f72419"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga94a8c3e4b9c01733ba077ee0cd17b0de"></a><!-- doxytag: member="boost::afio::handle::path" ref="ga94a8c3e4b9c01733ba077ee0cd17b0de" args="(bool refresh=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classboost_1_1afio_1_1path.html">boost::afio::path</a> <a class="el" href="group__async__io__handle____ops.html#ga94a8c3e4b9c01733ba077ee0cd17b0de">boost::afio::handle::path</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>refresh</em> = <code>false</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the path of this i/o handle right now if the handle is open and <em>refresh</em> is true, else last known good. May be null if the file has been deleted. </p>
<p>Note the refreshed path completely dereferences any intermediate symbolic links to return a truly absolute canonical path, and therefore may look quite different to before. Some operating systems unfortunately also return any one of the hard links to the file, so if hard links is greater than one the path refreshed will randomly permute.</p>
<p>Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by `afio::path` in NT kernel namespace paths. `normalise_path()` can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The path of this i/o handle right now. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">refresh</td><td>Whether to ask the OS for the current path of this handle.</td></tr>
  </table>
  </dd>
</dl>
<p>{ [raceguarantee FreeBSD..Paths are only refreshed for directories, not files.] [raceguarantee Linux, Windows..Paths are always refreshed and ignore other hard links.] [raceguarantee OS X..Paths are only refreshed for directories and files with a single hard link.] } </p>

</div>
</div>
<a class="anchor" id="ga491efe072ab2b3ca2d9cf044f8eed1ab"></a><!-- doxytag: member="boost::afio::handle::direntry" ref="ga491efe072ab2b3ca2d9cf044f8eed1ab" args="(metadata_flags wanted=directory_entry::metadata_fastpath())=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual directory_entry <a class="el" href="group__async__io__handle____ops.html#ga491efe072ab2b3ca2d9cf044f8eed1ab">boost::afio::handle::direntry</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__metadata__flags.html#ga228a95ca96f053e74e69e6d1ab23eccb">metadata_flags</a>&#160;</td>
          <td class="paramname"><em>wanted</em> = <code><a class="el" href="classboost_1_1afio_1_1directory__entry.html#a3ffc87e0e2d28facff8e2c5dd82c9e60">directory_entry::metadata_fastpath</a>()</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a mostly filled <a class="el" href="classboost_1_1afio_1_1directory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> for the file or directory referenced by this handle. Use `metadata_flags::All` if you want it as complete as your platform allows, even at the cost of severe performance loss. </p>
<p>Related types: `__afio_directory_entry__`, `__afio_stat_t__` </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A directory entry for this handle. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">wanted</td><td>The metadata wanted.</td></tr>
  </table>
  </dd>
</dl>
<p>{ [raceguarantee FreeBSD..Race free if handle open for directories and regular files only, else if handle closed or a symlink race free up to the containing directory. All metadata is fetched in a single shot.] [raceguarantee Linux..Race free if handle open, else if handle closed race free up to the containing directory. All metadata is fetched in a single shot.] [raceguarantee OS X..Race free if handle open for directories and regular files only. No guarantees if handle closed or a symlink.] [raceguarantee Windows..Handle must be open and is always race free. Metadata may be fetched in a single shot if at least two categories requested, or else the following categories apply: (i) ino (ii) type, atim, mtim, ctim, birthtim, sparse, compressed (iii) nlink, size, allocated, blocks.] } </p>

</div>
</div>
<a class="anchor" id="ga06c44b7c2c3fef3a223bf9e3843d701f"></a><!-- doxytag: member="boost::afio::handle::target" ref="ga06c44b7c2c3fef3a223bf9e3843d701f" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classboost_1_1afio_1_1path.html">boost::afio::path</a> <a class="el" href="group__async__io__handle____ops.html#ga06c44b7c2c3fef3a223bf9e3843d701f">boost::afio::handle::target</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the target path of this handle if it is a symbolic link. </p>
<p>Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by `afio::path` in NT kernel namespace paths. `normalise_path()` can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The path the symbolic link points to. May not exist or even be valid.</dd></dl>
<p>{ [raceguarantee FreeBSD..Race free up to the containing directory.] [raceguarantee Linux, Windows..Race free if handle open, else up to the containing directory.] [raceguarantee OS X..No guarantees.] } </p>

</div>
</div>
<a class="anchor" id="gaa637967d05be4d03eadb419dac95bf3c"></a><!-- doxytag: member="boost::afio::handle::link" ref="gaa637967d05be4d03eadb419dac95bf3c" args="(const path_req &amp;req)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="group__async__io__handle____ops.html#gaa637967d05be4d03eadb419dac95bf3c">boost::afio::handle::link</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structboost_1_1afio_1_1path__req.html">path_req</a> &amp;&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hard links the file to a new location on the same volume. </p>
<p>If you wish to make a temporary file whose contents are ready appear at a location and error out if a file entry is already there, use <a class="el" href="group__async__io__handle____ops.html#gaa637967d05be4d03eadb419dac95bf3c" title="Hard links the file to a new location on the same volume.">link()</a> and if success, <a class="el" href="group__async__io__handle____ops.html#gae7dbd14a44e4d306804ef2766057e5ae" title="Unlinks the file from its present location as determined by path(true), which could be any hard link ...">unlink()</a> on the former location. If you wish to always overwrite the destination, use <a class="el" href="group__async__io__handle____ops.html#ga7745df4fa1a42a9ae080de6ad8f72419" title="Links the file to a new location and unlinks the file from its present location as determined by path...">atomic_relink()</a> instead.</p>
<p>On Windows, the destination directory cannot have any handle opened to it with delete/rename privileges (`file_flags::write`) anywhere in the system. This is an operating system limitation.</p>
<p>Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by `afio::path` in NT kernel namespace paths. `normalise_path()` can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.</p>
<p>Related types: `__afio_path_req__`</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The absolute or relative (in which case precondition specifies a directory) path to create a hard link at.</td></tr>
  </table>
  </dd>
</dl>
<p>{ [raceguarantee FreeBSD..Race free up to the containing directory for both source and target.] [raceguarantee Linux, Windows..Race free for source if handle open, else up to the containing directory. Race free up to the target directory.] [raceguarantee OS X..No guarantees.] } </p>

</div>
</div>
<a class="anchor" id="gae7dbd14a44e4d306804ef2766057e5ae"></a><!-- doxytag: member="boost::afio::handle::unlink" ref="gae7dbd14a44e4d306804ef2766057e5ae" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="group__async__io__handle____ops.html#gae7dbd14a44e4d306804ef2766057e5ae">boost::afio::handle::unlink</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlinks the file from its present location as determined by path(true), which could be any hard link on those operating systems with an unstable path(true). Other links may remain to the same file. </p>
<p>On Microsoft Windows, this routine unlinks items as follows:</p>
<p>1. It tries to atomically rename the item to the root of the mounted volume it lives in with a .afiodXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX where the X's are a 128 bit crypto random hexadecimal. If that fails, it tries the next directory up, and the next after that until success if any. This rename may fail for any reason, including if it is a directory with open file handles somewhere within. If it fails, the rename is skipped.</p>
<p>2. It marks the item with hidden and system attributes to hide it from normal directory enumeration.</p>
<p>3. It sets the delete on last handle close flag. At some stl_future point Windows will delete the item, until which it will hang around in a zombie state with an unknowable name and location unopenable by any new processes.</p>
<p>The reason for such complexity is that this algorithm, if it renames successfully, neatly works around a number of annoying features in Windows, specifically that when you delete a file you actually don't delete it till an unknown amount of time later. This breaks code which tries to delete a directory tree, and finds that the directories won't delete because they still contain files supposedly deleted but actually not quite yet. By renaming the items as far away as possible, this problem ought to go away - unless of course that the user does not have permissions to write into any directory other than the one being eventually deleted, in which case you will still see the strange access denied and directory not empty errors from before.</p>
<p>Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by `afio::path` in NT kernel namespace paths. `normalise_path()` can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.</p>
<p>Related types: `__afio_path_req__`</p>
<p>{ [raceguarantee FreeBSD, Linux..Race free up to the containing directory.] [raceguarantee Windows..Race free if handle open, else up to the containing directory.] [raceguarantee OS X..No guarantees.] } </p>

</div>
</div>
<a class="anchor" id="ga7745df4fa1a42a9ae080de6ad8f72419"></a><!-- doxytag: member="boost::afio::handle::atomic_relink" ref="ga7745df4fa1a42a9ae080de6ad8f72419" args="(const path_req &amp;req)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="group__async__io__handle____ops.html#ga7745df4fa1a42a9ae080de6ad8f72419">boost::afio::handle::atomic_relink</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structboost_1_1afio_1_1path__req.html">path_req</a> &amp;&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Links the file to a new location and unlinks the file from its present location as determined by path(true), <em>atomically overwriting any file entry at the new location</em>. Very useful for preparing file content elsewhere and once ready, atomically making it visible at some named location to other processes. Note that operating systems with an unstable path(true) may relink any hard link to the file to the new location. </p>
<p>Note that not all filing systems guarantee the atomicity of the relink itself (i.e. the file may appear at two locations in the filing system for a period of time), though all supported platforms do guarantee the atomicity of the replaced location i.e. the location you are relinking to will always refer to some valid file to all readers, and will never be deleted or missing. Some filing systems may also fail to do the unlink if power is lost close to the relinking operation.</p>
<p>On Windows, the destination directory cannot have any handle opened to it with delete/rename privileges (`file_flags::write`) anywhere in the system. This is an operating system limitation.</p>
<p>Be aware that on Windows AFIO operates exclusively in the NT kernel namespace, NOT the Win32 namespace, and therefore paths you supply are converted by `afio::path` in NT kernel namespace paths. `normalise_path()` can convert an afio path back to a Filesystem TS path for you, but note that this may not be the path that was supplied originally. NT kernel namespace paths have a 32,767 character limit and an almost POSIX like lack of restrictions on naming or historical behaviour quirks, but as a result AFIO does not support DOS short names or any of the other historical Win32 filing system baggage.</p>
<p>Related types: `__afio_path_req__`</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The absolute or relative (in which case precondition specifies a directory) path to relink to.</td></tr>
  </table>
  </dd>
</dl>
<p>{ [raceguarantee FreeBSD, Linux..Race free up to the containing directory for both source and target.] [raceguarantee OS X..No guarantees.] [raceguarantee Windows..Race free for source if handle open, else up to the containing directory. Race free up to the target directory.] } </p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
