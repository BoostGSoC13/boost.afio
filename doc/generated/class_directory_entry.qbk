[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml/classboost_1_1afio_1_1directory__entry.xml]
[section:directory_entry directory_entry]

'''<indexterm><primary>directory_entry</primary></indexterm>'''
The abstract base class for an entry in a directory with lazily filled metadata. 

[heading Description]
Note that [^`directory_entry_hash`] will hash one of these for you, and a [^`std::hash<``directory_entry``>`] specialisation is defined for you so you ought to be able to use directory\u005fentry directly in an [^`unordered_map<>`].

[heading Synopsis]
``class directory_entry
{
  // ...
};
``

[heading Constructor(s)]
[table
[[Function] [Description] [Parameters] ]
[[``directory_entry()``

] [Default constructor. ] [


]]
[[``directory_entry(path::string_type _leafname, stat_t __stat, metadata_flags _have_metadata)``

] [Default constructor. ] [[* path::string_type]: ['_leafname]:  

[* stat_t]: ['__stat]:  

[* metadata_flags]: ['_have_metadata]:  




]]
[[``directory_entry(const directory_entry & )``

] [] [[* const directory_entry &]: [']:  




]]
[[``directory_entry(directory_entry && o)``

] [] [[* directory_entry &&]: ['o]:  




]]
]

[heading Member Function(s)]
[table
[[Function] [Description] [Parameters]  [Returns]]
[[``directory_entry & operator=(const directory_entry & )``

] [] [[* const directory_entry &]: [']:  




]]
[[``directory_entry & operator=(directory_entry && o)``

] [] [[* directory_entry &&]: ['o]:  




]]
[[``bool operator==(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  




]]
[[``bool operator!=(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  




]]
[[``bool operator<(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  




]]
[[``bool operator<=(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  




]]
[[``bool operator>(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  




]]
[[``bool operator>=(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  




]]
[[``path::string_type name()``

] [] [

][
The name of the directory entry. May be empty if the file is deleted. 


]]
[[``metadata_flags metadata_ready()``

] [] [

][
A bitfield of what metadata is ready right now 


]]
[[``metadata_flags fetch_metadata(std::shared_ptr< async_io_handle > dirh, metadata_flags wanted)``

] [Fetches the specified metadata, returning that newly available. This is a blocking call if wanted metadata is not yet ready. Note that if the call blocks and the leafname no longer exists or the directory handle is null, an exception is thrown. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An open handle to the entry's containing directory. You can get this from an op ref using dirop.h->get(). 

[* metadata_flags]: ['wanted]:  A bitfield of the metadata to fetch. This does not replace existing metadata. 



][
The metadata now available in this directory entry. 


]]
[[``stat_t fetch_lstat(std::shared_ptr< async_io_handle > dirh, metadata_flags wanted = directory_entry::metadata_fastpath())``

] [Returns a copy of the internal [^`stat_t`] structure. This is a blocking call if wanted metadata is not yet ready. Note that if the call blocks and the leafname no longer exists or the directory handle is null, an exception is thrown. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An open handle to the entry's containing directory. You can get this from an op ref using dirop.h->get(). 

[* metadata_flags]: ['wanted]:  A bitfield of the metadata to fetch. This does not replace existing metadata. 



][
A copy of the internal [^`stat_t`] structure. 


]]
[[``fieldtype st_dev(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_dev. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_ino(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_ino. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_type(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_type. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_perms(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_perms. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_nlink(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_nlink. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_uid(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_uid. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_gid(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_gid. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_rdev(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_rdev. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_atim(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_atim. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_mtim(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_mtim. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_ctim(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_ctim. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_size(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_size. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_allocated(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_allocated. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_blocks(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_blocks. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_blksize(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_blksize. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_flags(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_flags. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_gen(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_gen. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``fieldtype st_birthtim(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_birthtim. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``metadata_flags metadata_supported()``

] [A bitfield of what metadata is available on this platform. This doesn't mean all is available for every filing system. ] [


]]
[[``metadata_flags metadata_fastpath()``

] [A bitfield of what metadata is fast on this platform. This doesn't mean all is available for every filing system. ] [


]]
[[``size_t compatibility_maximum()``

] [The maximum number of entries which is "usual" to fetch at once i.e. what your libc does. ] [


]]
]

[heading Header]
`#include <boost/afio/afio.hpp>`

[include generated/struct_directory_entry_hash.qbk]

[endsect]

